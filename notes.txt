16.9.

PUSH_SWAP

        GUESTIONS

                1. Should I add 0 in the value places if the value "is out of numbers"?

        TO DO
				- Fix problem with argc size when recieving onyl 2 arguments
                - Figure out my free functions correctyl
                        - free stack A at the end // DONE
                        - free my split after stack created
                        - Free stack if it is already sorted and then exit
                        - Free stack B at the end?
                - Make sure all works:
                        - Does not sort if already sorted // DONE
						- Sorts with int args:
								- Sort between 2-5 elements // DONE
								- Sort more than 5 elements
						- Sort with only two arguments:
								- Sort between 2-5 elements
								- Sort more than 5 elements
                - Answer guestion and write about binary and other stuff I learned/realized today
                - Study and use struct in my program correctly and efficiently
                - Delete print_stack.c from header, files, makefile and stdio.h from header


15.9.

PUSH_SWAP

		CODE TODAY

				big_sort_stack.c
						Made with logic to only use stack operations with bit 0's -> move those to top and push to b. Still too many operations so need to optimize.

        TO DO
				- Figure out my free functions correctyl
						- free stack A at the end // DONE
						- free my split after stack created
						- Free stack if it is already sorted and then exit
						- Free stack B at the end?
                - Answer guestion and write about binary and other stuff I learned/realized today
                - Add headers to all my functions // DONE
                - Makefile // DONE
						- add libft with libft directory and add to push_swap makefile // DONE
                - In main function:
                        - Check if the stack is already sorted // DONE
                                - Go through the stack and compare always if the previous nbr is smaller, if not - stack is not sorted // DONE
                                - Function should return 0 or 1, depending if it is sorted or not // DONE
				- Make sure all works:
						- Does not sort if already sorted // DONE
                - Study and use struct in my program correctly and efficiently
				- Delete print_stack.c from header, files, makefile and stdio.h from header


14.9.

PUSH_SWAP

		GUESTIONS
		
				1. Should I add 0 in the value places if the value "is out of numbers"?

        TO DO
				- Answer guestion and write about binary and other stuff I learned/realized today
                - Sorting function: // DONE
                        - Big sorting with radix or counting sort // DONE
                                1. Find the max value of the stack // DONE
                                2. Count max value's bit amount and put into int binary_size // DONE
                                        - max/2 while max > 0 // DONE
                                3. While (binary_size > bite_place) // DONE
										- while stack A is not NULL // DONE
										- Check the binary's bit: // DONE
												- If bit == 1: continue // DONE
												- If bit == 0: // DONE
														- Move the element to top // DONE
														- Push to B // DONE
                                6. When we have checked all the element's value's in the place of binary_size: // DONE
                                        - push back to stack a // DONE
                                        - move to the next bite_place and do the same // DONE
				- Do proper tests for big and small sorts
				- Function to calculate the stack operations made OR create struct variable operation_counter and print that in my main?
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / else send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted - WHAT DO I PRINT IF TRUE?
                                - Go through the stack and compare always if the previous nbr is smaller, if not - stack is not sorted
                                - Function should return 0 or 1, depending if it is sorted or not
                        - Do tiny sort and big sort algorithms
                - Study and use struct in my program correctly and efficiently
                - Makefile
                - Maybe need to send in my swap.c functions & of a and &b when counting the stack? Check later if errors because of this
                - Add headers to all my functions
                - Delete my find_last_node function and change to always get second last and assing last = second_last->next?


13.9.

PUSH_SWAP

		CODE TODAY

				big_sort_stack.c

        GUESTIONS (also previous unanswered questions)

                1. What is the difference between radix sort and counting sort algorithms? Which one should be applying and why?
						
						ANSWER

							- Both are stable sorting algorithms. It means that they maintain the position of the unsorted elements even after sorting.
									- Input: Ka kb kc kB
									- Stable: Ka kb kB kc
									- Unstable: Ka kB kb kc

							Counting sort counts the amount of each value, stores those into a seperate array and sorts the original list following that order
									- Input: 3 0 6 0 4 3 0 2
									- Frequency array: (0)3 (1)0 (2)1 (3)2 (4)1 (5)0 (6)1
									- Element places in the new order: (0)3 (1)3 (2)4 (3)6 (4)7 (5)7 (6)8
									- New array: 00023346

							Radix sort compares the values with each others starting either MSD or LSD and goes forward like that through the whole numbers step by step. It
							divides each number into different buckets (same ones go together) and then returns them back together in ascending order.

							I want to apply radix because it will be more efficient with bigger numbers and when there is a lot of numbers.

                2. In my stack operation functions, should I only recieve one pointer cause I am not modifying the values in nodes, just moving nodes?
                3. In my tiny_sort_stack function, should I recieve only one pointer to stack cause not modifying the values of nodes?

						ANSWER
							- I should use double pointers because otherwise I can't reach elements to modify the pointers into pointing new elements in the stack.

                4. How should I check the values and compare them to see, which operations I need to do to know, what sorting operations to use?

						ANSWER
							- I can store the indexes of the values into my stack, access their binary form when sorting and compare them like that with radix sort.

                5. Do I need to malloc my last node in find_last_node function?

						ANSWER
							- I should not! Point is to find the last node and return pointer to that place. If I use malloc, I would create a new node which is not connected
								to the same list and then mess up my program with returning an empty node and possible leaks.

                6. What variables should I add to my struct and what I should leave out of it?

						ANSWER
							- I should add into my struct all variables that are related to my stack. Take more time to read about this and implement into my program.
							- So far I understood that if I declare size in my struct, I can calculate it once in my program and then use it or local copy of it without needing
								to always count it again. This will make a difference in the time complexity.
							- Also when passing a struct head pointers, I can use double pointers. But this is still unclear to me and I should read more about it.

        TO DO
                - Answer guestions // DONE
                - Sorting function:
                        - Big sorting with radix or counting sort
								1. Find the max value of the stack // DONE
                        		2. Count max value's bit amount and put into int binary_size // DONE
										- max/2 while max > 0
                   			    3. While (binary_size > bit_place) (bit_place starts from 1 so this will skip the last, NEED TO CHANGE LOGIC)
								? SHOULD I USE TEMP OR STACK A DIRECTLY ?
                       			4. Access the element's data's binary version // DONE
                       			5. If the nbr is 0 => push to b / If the nbr is 1 => move to the next element's value and check it in the same binary_size place
                       			6. When we have checked all the element's value's in the place of binary_size:
										- push back to stack a
										- move to the next bite_place and do the same
                       			7. Should I add 0 in the value places if the value "is out of numbers"? How?
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / else send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted - WHAT DO I PRINT IF TRUE?
                                - Go through the stack and compare always if the previous nbr is smaller, if not - stack is not sorted
                                - Function should return 0 or 1, depending if it is sorted or not
                        - Do tiny sort and big sort algorithms
				- Study and use struct in my program correctly and efficiently
                - Makefile
                -  Do function that calculates all the stack operations
                - Maybe need to send in my swap.c functions & of a and &b when counting the stack? Check later if errors because of this
                - Add headers to all my functions
				- Delete my find_last_node function and change to always get second last and assing last = second_last->next?


12.9.

PUSH_SWAP

		CODE TODAY

				- Changed tiny_sort and sort_helper functions for dealing with double pointers because was loosing the head of my stack. Because with single pointers I wasn't
					acctually touching the elements of the struckt.

				- Changed in my get_max_value
						- to look also when stack->data is equal to temp->data and not only when it is bigger. Now works correctly when sorting three numbers
						- Do while until temp != NULL (before: temp->next != NULL) because was not checking the last one
					in order 4 2 3.

				- Updated in sort_three temp = (*stack)->next also after ra operation

				- Created functions to sort between 2-5 numbers / tiny_sort_stack.c:
						 - Sort two or three // DONE
                                    - sort 3 2 correctly // DONE
                                    - sort 4 3 2 correctly // DONE
                                    - sort 4 2 3 correctly // DONE
                                    - sort 2 4 3 correctly // DONE
                                    - sort 3 4 2 correctly // DONE
                                    - sort 3 2 4 correctly // DONE
						- Sort four or five // DONE
                                    1. look for smallest nbr // DONE
                                    2. move it at the top of the stack A // DONE
                                    3. pb the smallest // DONE
                                    4. repeat 1.-3. if five nbrs // DONE
                                    5. sort stack A // DONE
                                    6. pa the smallest value(s) // DONE

		GUESTIONS

				1. What variables should I add to my struct and what I should leave out of it?

		TO DO
                - Answer guestions
                - Sorting functions:
                        - Create a sort_helper.c where I have functions to helo sorting the stack // DONE
                        - Tiny sort when five or less numbers // DONE
                       			- Sort two or three // DONE
                            	- Sort four or five // DONE
                        - Big sorting with radix or counting sort
								1. Count the amount of binary numbers in the biggest number and put to int binary_size
								2. Using bitwise operations:
										- if nbr == 0: pb
										- if nbr == 1: move to the next element's nbr
								3. When divided, push all back from B to A
								4. Move to the next binary place and repeat until binary_size is 0
								5. Should I some way add zeros if some binary numbers have more numbers than the others?
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / else send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted - WHAT DO I PRINT IF TRUE?
								- Go through the stack and compare always if the previous nbr is smaller, if not - stack is not sorted
								- Function should return 0 or 1, depending if it is sorted or not
                        - Do tiny sort and big sort algorithms
                - Makefile
                -  Do function that calculates all the stack operations
                - Maybe need to send in my swap.c functions & of a and &b when counting the stack? Check later if errors because of this
				- Add headers to all my functions


11.9.

PUSH_SWAP

		CODE TODAY

				- reverse_rotate
						- Corrected logic, was rejusting last pointer to point old second element and not the new second element. Changed to point to the old fist								 element which is the new second.


        TO DO
				- Put to do notes up to date, and stop being lazy with them on the first place. Reserve time for this everyday after studies !!!
				- Answer guestions
                - Sorting functions:
                        - Do function to count the size of the biggest binary number, WHY THOUGH? Something to do with searching the max nbr before sorting
                                - Create a sort_helper.c where I have functions to look the max value, find last node
                        - Tiny sort when five or less numbers
							- Sort three is working
							- Sort five is wrong, check comment on the file
                        - Big sorting with radix or counting sort
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / else send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted - WHAT DO I PRINT IF TRUE?
                        - Do tiny sort and big sort algorithms
                - Makefile
                -  Do function that calculates all the stack operations
                - Maybe need to send in my swap.c functions & of a and &b when counting the stack? Check later if errors because of this


10.9.

PUSH_SWAP

		CODE TODAY

				tiny_sort_stack.c
						- sort_three: this will sort the stack if there are only three numbers
								- Get the max value
								- Get the last node pointer
										- If max is first -> ra
										- If max is (last) -> do nothing to max
								- Check if first is bigger than second
										- If first > second -> sa
										- If first < second -> do nothing, stack is sorted

				sort_helper.c
						- Function to find_max_value
						- Function to return a pointer to min value

		GUESTIONS

				1. In my stack operation functions, should I only recieve one pointer cause I am not modifying the values in nodes, just moving nodes?

				2. In my tiny_sort_stack function, should I recieve only one pointer to stack cause not modifying the values of nodes?

				3. How should I check the values and compare them to see, which operations I need to do to know, what sorting operations to use
				
				4. Do I need to malloc my last node in find_last_node function?

        TO DO
				- Add pa and pb fuinctions that do nothing if stack a or stack b is empty, depending which we are pushing from // DONE
				- Add sa and sb and ss to do nothing if there is only one element. Check better at operation guidelines on subject // DONE
				- Same with rotate and reverse rotate functions: do nothing if no elements or only one element // DONE
				- Sorting functions:
                        - Do function to count the size of the biggest binary number, WHY THOUGH? Something to do with searching the max nbr before sorting
								- Create a sort_helper.c where I have functions to look the max value, find last node
                        - Tiny sort when five or less numbers
                        - Big sorting with radix or counting sort
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / else send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted - WHAT DO I PRINT IF TRUE?
                        - Do tiny sort and big sort algorithms
                - Makefile
                -  Do function that calculates all the stack operations
				- Maybe need to send in my swap.c functions & of a and &b when counting the stack? Check later if errors because of this


9.9.

PUSH_SWAP

		LEARNED TODAY

					- I dont need to build stack a with binary nimbers but I can use bitwise operations to access the binary form when needed. This way will use less memory.
		
		GUESTIONS

				1. How does the bitwise operations work?

							ANSWER
								- An integer digits are already stored in the memory at their binary forms. With bitwise operations, I can peek the binary form and use it when needed
								- I can use shift right (>>) to move into the binary number that I want to compare
								_ Then use & x to mask the values to compare with only that specific one

		TO DO
				- Learn bitwise operations and how I can use them in radix to get the bit form of the number when sorting the stack // DONE
                - Sorting functions:
						- Do function to count the size of the biggest binary number, WHY THOUGH? Something to do with searching the max nbr before sorting
                        - Tiny sort when five or less numbers
                        - Big sorting with radix or counting sort
                - Add pa and pb fuinctions that do nothing if stack a or stack b is empty, depending which we are pushing from. Check operation guidelines on subject
                - Add sa and pa to do nothing if there is only one element. Check better at operation guidelines on subject
                - Do split function
                        - Add on my main int *argvs that will store the ints after split
                        - if needed to do split, send argvs array to create_stack / if not, send the original argv
                - Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
                - In main function:
                        - Check if the stack is already sorted
                        - Do tiny sort and big sort algorithms
                - Makefile
                -  Do function that calculates all the stack operations


8.9.

PUSH_SWAP

		LEARNED TODAY

				RADIX SORT: is a linear sorting algorithm
						LSD Radix sort:
							1. get the max value of the array
							2. start sorting from the least significant digit to most

		GUESTIONS

				1. What is the difference between radix sort and counting sort algorithms? Which one should be applying and why?

				2. When creating a size to the array, should I first count the size of the binary, malloc that size to the array and then convert again to binary
					for adding the binary values to the array? Or is there a way to count the binary size otherwise so I wouldn't have to count modulo twice?
					Or have fixed size array

							ANSWER:
								 - I dont need to build stack a with binary nimbers but I can use bitwise operations to access the binary form when needed. This
								 	way will use less memory.

		TO DO
				- Do functiont to change index to binary form and send to be added to stack a
						- Create an array that stores the incex value as binary
						- Malloc the size of WHAT (or fixed size of WHAT)? <- CHECK GUESTION NO 2.
						- Modulo the index with 2 until index = 0
						- Store the modulos (0 or 1) to an array
						- Either reverse the array or start adding from the end to beginning
						- Send a pointer from that array to add_to_stack function
				- Sorting functions:
						- Tiny sort when under ? amount of numbers
						- Big sorting with ranix or counting sort
				- Add pa and pb fuinctions that do nothing if stack a or stack b is empty, depending which we are pushing from. Check operation guidelines on
					subject
				- Add sa and pa to do nothing if there is only one element. Check better at operation guidelines on subject
				- Do split function
						- Add on my main int *argvs that will store the ints after split
						- if needed to do split, send argvs array to create_stack / if not, send the original argv
				- Create only one error function for all and delete extra error functinos. Note that error_array is working incorrectly atm.
				- In main function:
						- Check if the stack is already sorted
						- Do tiny sort and big sort algorithms
				- Makefile
				-  Do function that calculates all the stack operations
			


6-7.9.

PUSH_SWAP

		CODE TODAY

				Files:
					stack_helper.c: 
								- Changed all while(a != NULL) to while (*a != NULL) because I need to dereferense to see if a points to null.

								- check_if_number:
										- Changed places with returnvalues 0 and 1, becaues if function is not successfull, it returns 0 or NULL, if successfull returns anything else.
										- Added a check if number has - or + sign, and if there is double - or + sign

					error_exit.c
								- Added *temp to be able to send stack instead of double pointer to count_stack_size. I don't want to send double pointer cause I am not modifying stack when
									counting it but my error_exit function recieves double pointer to stack because it is freeing the nodes so directly modifying it.

					create_stack.c
							- In create_stack function,In create_stack function, cchanged from i = 1 to:
										i = argc - 1, because I want to send the args from last to first to be able to add them into stack in correct order which is that the first argument
										given is going to be at the top of stack when stack a is created.
								- Changed create_stack and add_to_stack functions as voids cause I want to modify stack a directly in them. Also that's why they recieve a double pointer to 									stack instead of just t_node pointer

					array_helper.c:
							- Created functions to: create an array from argv's that were first checked to not include errors, then to sort it in ascending order and after get an index which
								is corresponding to it's place in argv line - and then put all the indexes into stakc a.

		GUESTIONS

					1. What is the best way to find smallest number in an array?

								ANSWER: Form of bubble sort?

					2. How to convert digits to binary in c?

								ANSWER: Take % 2 from the digit and quontent will be the next one to divide until it is 0 and modulo will be the presentation of the binary:
										43 % 2 = 1
										21 % 2 = 1
										10 % 2 = 0
										5 % 2 =  1
										2 % 2 =  0
										1 % 2 =  1
														so: 43 base 10 is 101011 in binary
							
		LEARNED TODAY

					- To be able to handle big binary numbers more efficiently, I can convert given args into an array, get their indexes in the array and sort them in their binary form:
							1. Create an array: handle_array.c -> create_stack will do the error checks, create an array, send it to sort_array function for sorting and return it to create_									stack. 
							2. Get the index of the numbers: handle_array.c -> get_index
							?. 
					- After creating the stack, need to check if the stack is already sorted
					- If the stack is not sorted, I need to sort it

	    TO DO NEXT

                - Add a check to see, if in arguments there are two signs which is not okay, should error exit if this is true // DONE
                - Learn about lldb to be able to debug my program // DONE
                - Delete functions printing different error messages in my error_exit.c file
				- Create functions to insert argv's into an array and get their indexes so I can sort the index binary instead of the possible super long binaries from big digit numbers // 						DONE
				- split
				- Fix error functions
                - Implement algorithm to use: radix
				- Add function that calculates every stack operation and outputs it when program is launched
                - Makefile


4.9.

PUSH_SWAP

	CODE TODAY

				- Changed in main to send &stack as a double pointer so I could modify it directly in my create_stack function
						- Changed create_stack declarations to recieve a double pointer

				- Sending double pointer from stack a to error functions because I want to free the nodes from the stack - and thinking that it equals as modifying
					directly the stack

	LEARNED TODAY

				HOW TO MOVE AND MODIFY SINGLE AND DOUBLE POINTERS BETWEEN FUNCTIONS:
	
					SINGLE:
							#include <stdio.h>

							void	test_pointers(int *p)
							{
								printf("Print first element: %d\n",*p);
								*p += 1;
								printf("Increased in the first element: %d\n",*p);
								p++;												 // is the same than: p += 1;
								printf("Moved to the next element: %d\n",*p);
								*p += 1;
								printf("Increased in the second element: %d\n",*p);
							}

							int	main(void)
							{
								int	arr[2] = {2, 88};

								printf("Before function: %d\n",*arr);
								test_pointers(arr);
								printf("After function: %d\n", *arr);
								return (0);
							}

							printing: NOTE: arr's first element is still 2->3 after the function test_pointers

							Before function: 2
							Print first element: 2
							Increased in the first element: 3
							Moved to the next element: 88
							Increased in the second element: 89
							After function: 3

					DOUBLE:
							#include <stdio.h>

							void	test_pointers(int **pp)
							{
								printf("Inside first element: %d\n", **pp);
								**pp += 1;
								printf("Increased the first element: %d\n", **pp);
								*pp += 1;
								printf("Moved up to second element: %d\n", **pp);
								**pp += 1;
								printf("Increased the second element: %d\n", **pp);
							}

							printing: NOTE: with double pointer, I can modify the original array. And when I move up in the elements, the current element will become the 												first element.

							int	main(void)
							{
								int	arr[2] = {2, 88};
								int	*p;

								p = arr;
								printf("Before function: %d\n",*p);
								test_pointers(&p);
								printf("After function: %d\n", *p);
								return (0);
							}

		GUESTIONS
		
				AM I DOING A MISTAKE WHEN USING DOUBLE POINTERS? DOES IT MEAN THAT STACK IS NOT STACK ANYMORE BUT A DOUBLE POINTER? Maybe should not use doublepointers?

	TO DO NEXT

				- Create test main to test creating my stack a // DONE
				- Create ssh, link to github and push my project there // DONE
				- Test and learn deeper about yesterday's points about pointers // DONE
				- Go through all my pointers in the program and correct if needed // DONE
				- Add a check to see, if in arguments there are two signs which is not okay, should error exit if this is true
				- Learn about lldb to be able to debug my program
				- Change error messages back to just error
				- Algorithm: radix or turk
				- Makefile


3.9.

PUSH_SWAP

	CODE TODAY

			Files:

				exit_error.c
						1. Count stack size and give it to variable i
						2. Free stack a nodes while i > 0
						3. Write error message and newline
						4. Exit the program with exit status 1 to tell that ran into an error

	LEARNED TODAY

			EXIT FUNCTION: Exit function terminates the current program, and so, it is a void and does not return anything. Function takes an int as an argument to tell
							the status of the program.
							- 0 = that the program ran successfully
							- 1 = that there was an error in the program
			
					declaration:
							void	exit(int status); // library stdlib.h
				
					Exit function will do the next processes:
						1. Call the functions registered with the atexit(3) function, in
            					the reverse order of their registration. (terminates all the programs which are running)
						2. Flush all open output streams. (flushes all the file buffers)
						3. Close all open streams. (closes all the stream)
						4. Unlink all files created with the tmpfile(3) function. (deletes all temporary files)

			POINTERS AND DOUBLE POINTERS

	TO DO NEXT

			- Answer yesterday's guestion // DONE
			- Function to: free nodes, print error message and exit the program // DONE
			- Make condition to handle if in arguments there are two signs before number
			- Test to create and print the stack
			- Makefile
			- Algorithm


2.9

PUSH_SWAP

	CODE TODAY

			Files:
				create_stack.c
						t_node  add_to_stack: Changed return type if new_node malloc fales because the function is not void
							- Before: return ;
							- Now: return (NULL);

						t_node	reate_stack: Added a check in the while loop after adding a new node to stack a because if the malloc in new_node failed, error and exit
							- Before: after the line "*a = add_to_stack(*a, (int)nbr);" came i++;
							- Now: between those added if (a == NULL)
															error_exit;

	LEARNED TODAY

			- That return ; can be only used in void functions because we are literally returning nothing.

			- For my stack operation functions, I should send only stack wihtout * or & because the stack is already a pointer in my code and functions that modify stack, should take a stack pointer.


	GUESTIONS

		1. How to handle errors by freeing and exiting?

				ANSWER:
						- Count the amount of nodes and put to i
						- Free while i > 0
						- print error message with write function
						- use exit function to quit and exit the program

	TO DO NEXT
	    - print error and free if error. how to exit a function? should I imitate some std function to handle errors? // NOTE: no, I can use exit function
        - solve my previous day guestions // DONE
        - makefile
        - test creating and printing stack
        - choose an algorithm and input it


27.8.

PUSH_SWAP

	CODE TODAY

		Updated push_swap.h and added all the functions done so far.

		Files:
			rotate.c
				- Changed logic in while -> last = last->next; INSTEAD last = *top->next // because it is dangerous to modify the top pointer
				- Added * to top cause it is ** and we cant acces to it without *-sign - before was just top
				- Added if statements to handle if the node or second node does not exist and we have nothing to rotate

			reverse_rotate.c
				- Changed logic in while -> second_last = second_last->next; INSTEAD second_last = second_last->next->next // because otherwise it will point to NULL instead of last node
				- Added * to top cause it is ** and we cant acces to it without *-sign - before was just top
				- Added if statements to handle if the node or second node does not exist and we have nothing to rotate

			push.c includes: push, push_a, push_b
				- Decided to link all to each other without copy because seemed much more simple:
						n1 = *src;
			  	 		*src = n1->next;
    					n1->next = *b;
    					*b = n1;

			stack_helper.c includes: check_if_nbr, check_if_double, ft_atol

			create_stack.c include: create_stack, add_to_stack
				- Returning *a because stack is a pointer that points to more pointers

	LEARNED TODAY

		New consepts:

				TRAVERSAL of a single linked list = moving through and accessing each node of the list until NULL

	GUESTIONS

		1. What return ; actually does?

				ANSWER:
					It is saying: "stop here, exit function now and return nothing". This is valid only with void functions as only void returns nothing.

		2. Do I need to allocate memory for the new node in b when pushing a node from stack a to b?

				ANSWER:
					Depends. If I copy the node, I need to malloc the size of a new node but I can also just link them again in a new order and then I don't need to malloc. Chose to link in a new way.

		3. In my stack operation functions, should I send & of stack or * of stack to the functions?

				ANSWER:
					If stack is already a pointer, I only send the stack but if it is an array, I should send an address

	TO DO NEXT
		- Think also about: delete modify_stack.c name and add add_to_stack function to create_stack.c / create stack_helper.c and add there atol, stack_size, all stack check functins // DONE;
	   	- create a new_node to my stack and insert the value there // DONE;
		- print error and free if error
		- solve my guestions
		- makefile
		- test creating and printing stack
		- choose an algorithm and input it


26.8.

PUSH_SWAP

	CODED TODAY

		Files:
			swap.c includes: void	swap(t_node **top) / void	swap_a(t_node **a) / void	swap_b(t_node **b) / void	swap_ab(t_node **a, t_node **b)
				- own functions to: a, b, ab, because want to print the commands everytime using that operation

			rotate.c includes: void	rotate(t_node **top) / void	rotate_a(t_node **a) / void	rotate_b(t_node **b) / void	rotate_ab(t_node **a, t_node **b)
				- own functions to: a, b, ab, because want to print the commands everytime using that operation

			reverse_rotate.c includes: void	reverse_rotate(t_node **top) / void	reverse_rotate_a(t_node **a) / void	reverse_rotate_b(t_node **b) / void	reverse_rotate_ab(t_node **a, t_node **b)
				- own functions to: a, b, ab, because want to print the commands everytime using that operation

	LEARNED TODAY

		Explanation of checks before operating in stack:

			if (!top || !*top || !(*top)->next)
				return ;

				!top = check if the function was called with NULL instead of real value in top -> rotate(NULL); instead of rotate(&a);
				!*top = check if the stack is empty and first node is NULL
				!(*top)->next = check if the first node's next is NULL (= second node is NULL)
	
		Syntax for singly linked list:

			Access a node and assign or get it's value:
	
				-> = structure dereference operator // it is used with structure pointers in linked lists to access the members of that struct

				*top = n1; // top pointer will point to the first node

				n1->next // next is pointin to the address of 2nd node

				*top->next->next->data // this will give me the access of 3rd node's value

				Get the last node of the list:
					while (last->next != NULL)
						last = last->next;

				Get the 2nd last node of the list:
					while (second_last->next->next != NULL)
						second_last = second_last->next;

				Accessing with a pointer;
					struct s_node	*top;

					(*top).data = 7; // dereferencing and assigning a value to node pointed by top pointer
					top->data = 7; // doing the same thing but with a shortening code syntax
					
					(*top).next = NULL; // again, this is first dereferencing inside the () and then assigning the value NULL
					top->next = NULL; // and this is the same with shortening code syntax

					Commonly used when:
							- Dynamically allocating memory
							- Sharing the same struct across different functions
							- Building linked data structures (linked lists, tree, graph
							- Wanting polymorphism-style behaviour (e.g passing around "handles" to big objects)
							- polymorphism = I DO NOT UNDERSTAND WHAT THIS MEANS YET

				Accessing with an object (not a pointer!)
					struct s_node	top;

					top.data = 7;
					top.next = NULL;

					Commonly used when:
							- The struct is small and has clear, fixed lifetime
							- No need to share it between functions
							- Exmaples: a single config project, a 2D point, small struct on the stack

	GUESTIONS

		1. How does the computer know to get that value through the word data? aKa how do I tell that to the computer?
				*top->next->next->data // this will give me access to the 3rd node's value

				ANSWER:

					- I create a struct in push_swap.h file and there declare variables: int data / struct node *next;
						typedef	struct	s_node
						{
							int	data; 
							struct s_node	*next;
						}
					- Because of that, the computer knows when I want to access the data or the pointer next (which includes the address of next node) part of the node
					

	TO DO NEXT
		- Figure out better way to find the last node in rotate.c than: last--; // apparently it is not even possible to decrement like this // DONE (see syntax for singly linked lists)
		- Figure out better way to find the second last node in reverse_rotate.c than: second_last--; // DONE (see syntax for singly linked lists)
		- Finish rotate.c and reverse_rotate.c // DONE
		- push // DONE
	   	- create a new_node to my stack and insert the value there
		- test creating and printing stack
		- choose an algorithm and input it
